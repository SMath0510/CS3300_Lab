//
// Generated by JTB 1.3.2
//

// lagging by 1
// pointing to some other block

package visitor;
import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class Pass1<R,A> implements GJVisitor<R,A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //


   public static class blockAttr {
        Integer block_line_number;
        Integer succ_block;
        Integer jump_block;
        String jump_block_name;
        Set<String> def_set;
        Set<String> use_set;
        Set<String> out_set;
        Set<String> in_set ;

        public blockAttr() {
            block_line_number = -1;
            succ_block = -1;
            jump_block = -1;
            jump_block_name = "-1";
            def_set = new HashSet<String>();
            use_set = new HashSet<String>();
            out_set = new HashSet<String>();
            in_set  = new HashSet<String>();
        }

        public void print() {
            System.out.println("Block Line: " + block_line_number);
            System.out.println("Succ Block: " + succ_block);
            System.out.println("Jump Block: " + jump_block);
            System.out.println("Define: " + def_set);
            System.out.println("Used: " + use_set);
            System.out.println("IN: " + in_set);
            System.out.println("OUT: " + out_set);
        }
    }

    public static class intervalAttr{
      String name;
      Integer start_line;
      Integer end_line;
      Integer stack_location;
      String allocated_register;
      // first out last in
      public intervalAttr(){
         name = "-1";
         start_line = 1000000;
         end_line = -1;
         allocated_register = "-1";
         stack_location = -1;  
      }

      public intervalAttr(Integer start, Integer end){
         name = "-1";
         start_line = start;
         end_line = end;
         allocated_register = "-1"; 
         stack_location = -1;    
      }

       public intervalAttr(String vname, Integer start, Integer end){
         name = vname;
         start_line = start;
         end_line = end;
         allocated_register = "-1";
         stack_location = -1;
      }

      public void print(){
         System.out.println("Name: " + name + ", START: " + start_line + ", END: " + end_line + ", REG: " + allocated_register + " STACK: " + stack_location);
      }
    }

    public static class funcAttr {
        String name;
        Integer num_args;
        Integer max_args;
        Integer curr_stack_pointer;
        Integer stack_capacity;
        Boolean call_check;
        Boolean spilled_check;
        Map<String, Integer> label_map;
        ArrayList<blockAttr> block_list;
        Map<String, intervalAttr> range_map;
        ArrayList<intervalAttr> active_interval_list;
        ArrayList<intervalAttr> interval_list;
        ArrayList<intervalAttr> stack_space;

        public funcAttr(String name) {
            this.name = name;
            num_args = 0;
            max_args = 0;
            curr_stack_pointer = 0;
            stack_capacity = 0;
            call_check = false;
            spilled_check = false;
            label_map = new HashMap<String, Integer>();
            block_list = new ArrayList<blockAttr>();
            range_map = new HashMap<String, intervalAttr> ();
            active_interval_list = new ArrayList<intervalAttr> ();
            interval_list = new ArrayList<intervalAttr> ();
            stack_space = new ArrayList<intervalAttr> ();
        }

        public void print(){
         System.out.println("Func Name: " + name);
         System.out.println("Num args: " + num_args);
         System.out.println("Called ?: " + call_check);
         System.out.println("Label Map\n: " + label_map);
         System.out.println("Blocks: " + block_list.size());
         for (blockAttr pr_block : block_list) {
            pr_block.print();
         }
        }
   }

   Integer line_count = 1;
   Integer arg_cnt = 0;
   blockAttr curr_block = new blockAttr();
   funcAttr curr_func = new funcAttr("TEMP");
   public Map<String, funcAttr> func_list = new HashMap<String, funcAttr>();
   Map<String, Integer> label_lineMap = new HashMap<String, Integer> ();
   ArrayList<String> free_reg_list = new ArrayList<>(Arrays.asList("s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7", "t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7", "t8", "t9"));
   Integer free_registers = 18;
   Boolean label_check = true;
   Boolean print_status = true;
   Boolean label_debug = false;
   Boolean line_debug = false;
   Boolean block_debug = false;
   Boolean move_debug = false;
   Boolean last_line_debug = false;
   Boolean interval_debug = false;
   Boolean reg_debug = false;
   Boolean in_out_debug = false;
   Boolean reg_stack_status_debug = false;
   Boolean final_run_debug = false;
   Boolean free_print = false;
   Boolean live_range_print = false;
   Boolean complete_print = false;
   Boolean interval_print = false;


   public void process_labels(funcAttr func){
      for (blockAttr battr : func.block_list) {
         String label_name = battr.jump_block_name;
         if(!label_name.equals("-1")){
            Integer label_line = label_lineMap.get(label_name);
            battr.jump_block = label_line;
         }
      }
   }


   public void get_in_out(funcAttr func)
   {
      Boolean different = true;
      blockAttr first_block = new blockAttr();
      first_block = func.block_list.get(0);
      Integer first_line_number = first_block.block_line_number;
      while(different){
         different = false;
         for(int i = func.block_list.size() - 1; i >= 0; i--){
            blockAttr battr = func.block_list.get(i);
            // block on ith line
            Set<String> in_blocks = new HashSet<String> (battr.in_set);
            Set<String> out_blocks = new HashSet<String> (battr.out_set);
            Set<String> out_def = new HashSet<String> (battr.out_set);

            // in = use + (out - def)
            out_def.removeAll(battr.def_set);
            battr.in_set.clear();
            battr.in_set.addAll(out_def); 
            battr.in_set.addAll(battr.use_set);
            if(in_out_debug){
               System.out.println("VAR: " + battr.block_line_number);
               System.out.println("IN: " + battr.in_set);
               System.out.println("OUT - DEF: " + out_def);
               System.out.println("OUT: " + battr.out_set);
               System.out.println("DEF: " + battr.def_set);
            }

            // out = union of in[succ]
            Integer succ1 = battr.jump_block;
            Integer succ2 = battr.succ_block;

            
            blockAttr succ_block1 = new blockAttr();
            blockAttr succ_block2 = new blockAttr();
            if(succ1 != -1) succ_block1 = func.block_list.get(succ1 - first_line_number);
            if(succ2 != -1) succ_block2 = func.block_list.get(succ2 - first_line_number);

            battr.out_set.clear();
            if(succ1 != -1) battr.out_set.addAll(succ_block1.in_set);
            if(succ2 != -1) battr.out_set.addAll(succ_block2.in_set);


            if(!out_blocks.equals(battr.out_set) || !in_blocks.equals(battr.in_set)){
               different = true;
            }

         }
      }
   }

   // first out last in
   public void get_live_range(funcAttr func){
      for(blockAttr battr: func.block_list){
         Integer line_number = battr.block_line_number;
         for(String temp: battr.out_set){
            if(!func.range_map.containsKey(temp)){
               // new entry
               intervalAttr interval = new intervalAttr(temp, line_number, line_number); // first out -- last in
               func.range_map.put(temp, interval);
            }
         }

         for(String temp: battr.in_set){
            if(func.range_map.containsKey(temp)){
               intervalAttr interval = func.range_map.get(temp);
               interval.end_line = line_number; // last in
            }
            else{
               intervalAttr interval = new intervalAttr(temp, line_number, line_number); // first out -- last in
               func.range_map.put(temp, interval);
            }
         }
      }
   }

   public void print_free_regs(){
      System.out.print("Free Registers: " + "[" + free_reg_list.size() + "] == ");
      for(String reg: free_reg_list){
         System.out.print(reg + " ");
      }
      System.out.println();
   }

   public void linear_scan(funcAttr func){
      for(Map.Entry<String, intervalAttr> elem1 : func.range_map.entrySet()){
         intervalAttr interval = elem1.getValue();
         func.interval_list.add(interval);
      }
      Collections.sort(func.interval_list, Comparator.comparingInt(i -> i.start_line));
      
      if(interval_debug) {
         System.out.println("Sorted for " + func.name);
         System.out.println("THE INTERVAL LIST SORTED: ");
         for(intervalAttr interval : func.interval_list){
            interval.print();
         }
      }

      for (intervalAttr interval : func.interval_list) {
         expire_old_intervals(interval, func);

         if (func.active_interval_list.size() == free_registers) {
            if(reg_debug) System.out.println("FULL CAPACITY");
            func.spilled_check = true;
            spill_at_interval(interval, func);
         }
         else {
            interval.allocated_register = get_free_register(func);
            func.active_interval_list.add(interval);
            Collections.sort(func.active_interval_list, Comparator.comparingInt(i -> i.end_line));
         }
         if(reg_stack_status_debug){
            System.out.println("1. INTERVAL: " + interval.name + " REG: " + interval.allocated_register + " STACK: " + interval.stack_location);
            if(interval_print) print_intervals();
         }
         if(free_print) print_free_regs();
      }

   }

   public void expire_old_intervals(intervalAttr curr_interval, funcAttr func){
      Collections.sort(func.active_interval_list, Comparator.comparingInt(i -> i.end_line));
      ArrayList<intervalAttr> to_remove = new ArrayList<>();
      for (intervalAttr interval : func.active_interval_list) {
         if (interval.end_line < curr_interval.start_line) {
            to_remove.add(interval);
         }
      }

      for (intervalAttr interval : to_remove) {
         func.active_interval_list.remove(interval);
         if(reg_debug) System.out.println("Back to pool: " + interval.allocated_register + " -> " + interval.name);
         add_register_to_pool(interval.allocated_register, func);
      }
   }

   public void spill_at_interval(intervalAttr curr_interval, funcAttr func){
      Integer active_size = func.active_interval_list.size();
      intervalAttr spill_interval = func.active_interval_list.get(active_size - 1);
      if (spill_interval.end_line > curr_interval.end_line) {
         curr_interval.allocated_register = spill_interval.allocated_register;
         func.active_interval_list.remove(spill_interval);
         spill_interval.allocated_register = "-1"; // unallocate the allocated_register
         func.active_interval_list.add(curr_interval);
         Collections.sort(func.active_interval_list, Comparator.comparingInt(i -> i.end_line));
         // move this spilled interval into stack
         spill_interval.stack_location = func.curr_stack_pointer;
         func.curr_stack_pointer ++;
         func.stack_space.add(spill_interval);
         if(reg_stack_status_debug) System.out.println("Spilled " + spill_interval.name + " into stack at " + spill_interval.stack_location);

      } else {
         // move  the current interval into stack
         curr_interval.stack_location = func.curr_stack_pointer;
         func.curr_stack_pointer ++;
         func.stack_space.add(curr_interval);
      }
   }

   public String get_free_register(funcAttr func){
      String free_reg = "-1";
      if(free_reg_list.size() > 0){
         free_reg = free_reg_list.get(0);
         free_reg_list.remove(free_reg);
      }
      return free_reg;
   }

   public void add_register_to_pool(String allocated_register, funcAttr func){
      
      if (!allocated_register.equals("-1")) {
         free_reg_list.add(allocated_register);
      }
   }

   public void set_numbers(funcAttr func){
      for(intervalAttr interval: func.interval_list){
         
         // System.out.println(interval.name + " {" + interval.start_line + " - " + interval.end_line + "}" + "REGISTER: " + interval.allocated_register + " STACK: " + interval.stack_location);
         // String name = interval.name;
         // if(func.range_map.containsKey(name)){
         //    intervalAttr mod_interval = func.range_map.get(name);
         //    mod_interval.name = name;
         //    mod_interval.allocated_register = interval.allocated_register;
         //    mod_interval.stack_location = interval.stack_location;
         //    System.out.println(name + " -- " + mod_interval.allocated_register + " <> " + mod_interval.stack_location);
         // }
      }
      func.curr_stack_pointer += Math.max(0, func.num_args - 4);
      func.stack_capacity = func.curr_stack_pointer;
      if(!func.name.equals("MAIN")) func.stack_capacity += 8;
      if(func.call_check) func.stack_capacity += 10;
   }


   public void print_live_ranges(){
      for(Map.Entry<String, funcAttr> elem1 : func_list.entrySet()){
         funcAttr func = elem1.getValue();
         System.out.println("Function: " + func.name);
         for(Map.Entry<String, intervalAttr> elem2 : func.range_map.entrySet()){

            String name = elem2.getKey();
            intervalAttr interval = elem2.getValue();
            System.out.println(name + " {" + interval.start_line + " - " + interval.end_line + "}" + "REGISTER: " + interval.allocated_register + " STACK: " + interval.stack_location);
         }
      }
   }


   public void print_all(){
      for(Map.Entry<String, funcAttr> elem : func_list.entrySet()){
         funcAttr func = elem.getValue();
         func.print();
      }
   }

   public void free_all_regs(){
      free_reg_list = new ArrayList<>(Arrays.asList("s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7", "t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7", "t8", "t9"));
   }

   public void print_intervals(){
      for(Map.Entry<String, funcAttr> elem1 : func_list.entrySet()){
         funcAttr func = elem1.getValue();
         System.out.println("FUNCTION " + func.name);
         for(intervalAttr interval : func.interval_list){
            interval.print();
         }
      }
   }

   public void final_run()
   {
        for (Map.Entry<String, funcAttr> elem : func_list.entrySet())
        {
            funcAttr func = elem.getValue();
            if(final_run_debug) System.out.println("Analysing and running final on " + func.name);
            process_labels(func);
            if(final_run_debug) System.out.println("Label processed for " + func.name);
            Integer num_blocks = func.block_list.size();
            blockAttr last_block = func.block_list.get(num_blocks-1);
            last_block.succ_block = -1;
            last_block.jump_block = -1;
            
            blockAttr second_last_block = func.block_list.get(num_blocks-2);
            second_last_block.succ_block = -1;
            second_last_block.jump_block = -1;
            if(last_line_debug) System.out.println("Last block line: " + last_block.block_line_number);
            get_in_out(func);
            if(final_run_debug) System.out.println("In out processed for " + func.name);
            get_live_range(func);
            if(final_run_debug) System.out.println("Live range processed for " + func.name);
      
            if(complete_print) print_all();
            linear_scan(func);
            if(final_run_debug) System.out.println("Linear Scan done for " + func.name);
            
            set_numbers(func);
            if(final_run_debug) System.out.println("Numbers set for " + func.name);
            free_all_regs();

            if(interval_print) print_intervals();
        }
      if(live_range_print) print_live_ranges();
    }

   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }


   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return null; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      R _ret=null;
      curr_func = new funcAttr("MAIN");
      func_list.put("MAIN",curr_func);
      n.f0.accept(this, argu);
      blockAttr battr1 = new blockAttr();
      curr_block = battr1;
      curr_block.block_line_number = line_count;
      curr_block.succ_block = line_count + 1;
      curr_block.jump_block = -1;
      curr_func.block_list.add(curr_block);
      line_count ++;
      
      if(line_debug) System.out.println("IN GOAL ++");

      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      blockAttr battr2 = new blockAttr();
      curr_block = battr2;
      curr_block.block_line_number = line_count;
      curr_block.succ_block = line_count + 1;
      curr_block.jump_block = -1;
      curr_func.block_list.add(curr_block);
      line_count ++;

      if(line_debug) System.out.println("IN GOAL ++");

      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      final_run();
      return _ret;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   // done ?
   public R visit(StmtList n, A argu) {
      R _ret=null;
      // some argu ??
      // return (R) 
      String label_status = "label";
      n.f0.accept(this, (A) label_status);
      return _ret;
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String label_name = (String) n.f0.f0.tokenImage;
      curr_func = new funcAttr(label_name);
		curr_func.num_args = (Integer) n.f2.accept(this, argu);
      func_list.put(label_name, curr_func);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      blockAttr battr = new blockAttr();
      curr_block = battr;
      curr_block.block_line_number = line_count;
      curr_block.succ_block = line_count + 1;
      curr_block.jump_block = -1;
      curr_func.block_list.add(curr_block);
      line_count ++;
      if(line_debug) System.out.println("IN PROCEDURE ++");
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   // done
   public R visit(Stmt n, A argu) {
      R _ret=null;
      blockAttr battr = new blockAttr();
      curr_block = battr;
      curr_block.block_line_number = line_count;
      Integer next_line = line_count + 1;
      curr_block.succ_block = next_line;
      curr_block.jump_block = -1;
      curr_func.block_list.add(curr_block);
      if(block_debug) System.out.println("Block: " + line_count + " added in " + curr_func.name);
      if(block_debug) curr_block.print();
      line_count ++; // next block
      if(line_debug) System.out.println("IN STMT ++");
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   // done
   public R visit(NoOpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   // done
   public R visit(ErrorStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */

    // NEED TO CHECK WHAT TO DO WITH THE BLOCKS
   public R visit(CJumpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String arg_status = "use";
      n.f1.accept(this, (A) arg_status);
      label_check = false;
      n.f2.accept(this, argu);
      label_check = true;
      String label_name = (String) n.f2.f0.tokenImage;
      curr_block.jump_block_name = curr_func.name + "__" + label_name;
      // get line number of the label and add that as a successor
      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */

    // NEED TO CHECK WHAT TO DO WITH THE BLOCKS
   public R visit(JumpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String label_name = (String) n.f1.f0.tokenImage;
      // Integer curr_block_size = curr_block.succ_block.size(); 
      // curr_block.succ_block.remove(curr_block_size - 1);
      curr_block.succ_block = -1;
      // function block (?)
      // curr_block.succ_block.add(label_line);
      curr_block.jump_block_name = curr_func.name + "__" + label_name;
      // get line number of the label and add that as a successor
      label_check = false;
      n.f1.accept(this, argu);
      label_check = true;
      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   // done
   public R visit(HStoreStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String arg_status1 = "use";
      n.f1.accept(this, (A) arg_status1);
      n.f2.accept(this, argu);
      String arg_status2 = "use";
      n.f3.accept(this, (A) arg_status2);
      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   // done
   public R visit(HLoadStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String arg_status1 = "def";
      n.f1.accept(this, (A) arg_status1);
      String arg_status2 = "use";
      n.f2.accept(this, (A) arg_status2);
      n.f3.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   // done
   public R visit(MoveStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String arg_status = "def";
      n.f1.accept(this, (A) arg_status);
      if(move_debug) System.out.println("TEMP " + n.f1.f1.f0.tokenImage + " moved to " + line_count + " in the function " + curr_func.name);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   // done
   public R visit(PrintStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   
   // done
   public R visit(Exp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   // done
   public R visit(StmtExp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      blockAttr battr1 = new blockAttr();
      curr_block = battr1;
      curr_block.block_line_number = line_count;

      curr_func.block_list.add(curr_block);
      line_count ++;
      if(line_debug) System.out.println("IN STMTEXP ++");
      n.f1.accept(this, argu); // some blocks might be here
      // return statement new block
      blockAttr battr2 = new blockAttr();
      curr_block = battr2;
      curr_block.block_line_number = line_count;
      curr_block.succ_block = line_count + 1;
      curr_block.jump_block = -1;
      curr_func.block_list.add(curr_block);
      if(block_debug) System.out.println("Block: " + line_count + " added in " + curr_func.name);
      if(block_debug) curr_block.print();
      line_count ++;
      if(line_debug) System.out.println("IN STMTEXP ++");
      // function Block
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      blockAttr battr3 = new blockAttr();
      curr_block = battr3;
      curr_block.block_line_number = line_count;
      curr_block.succ_block = line_count + 1;
      curr_block.jump_block = -1;
      curr_func.block_list.add(curr_block);
      line_count ++;
      if(line_debug) System.out.println("IN STMTEXP ++");
      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
    // done
   public R visit(Call n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String arg_status1 = "use";
      n.f1.accept(this, (A) arg_status1);
      n.f2.accept(this, argu);
      String arg_status2 = "arg";
      arg_cnt = 0;
      n.f3.accept(this, (A) arg_status2);
      n.f4.accept(this, argu);
      curr_func.max_args = Math.max(curr_func.max_args, arg_cnt);
		curr_func.call_check = true;

      // function block
      return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   // done
   public R visit(HAllocate n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
    // done
   public R visit(BinOp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String arg_status = "use";
      n.f1.accept(this, (A) arg_status);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   // done
   public R visit(Operator n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   // done
   public R visit(SimpleExp n, A argu) {
      R _ret=null;
      String arg_status = "use";
      n.f0.accept(this, (A) arg_status);

      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   // done
   public R visit(Temp n, A argu) {
      R _ret=null;
      String arg_status = (String)argu;
      n.f0.accept(this, argu);
      Integer num_val = (Integer) n.f1.accept(this, argu);
		if(arg_status == null) return _ret;
      // System.out.println("Whats the status?: " + n.f1.f0.tokenImage + " " + curr_func.name + " " + arg_status);
		if(arg_status.equals("use") || arg_status.equals("arg")) curr_block.use_set.add("TEMP " + num_val);
		else if(arg_status.equals("def")) curr_block.def_set.add("TEMP " + num_val);
		
      if(arg_status.equals("arg")) {
         arg_cnt ++;
      }
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   // done
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String var_str = (String) n.f0.tokenImage;
      Integer var_val = (Integer) Integer.parseInt(var_str);
      return (R) var_val;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   // done (change)
   public R visit(Label n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String id_name = (String) n.f0.tokenImage;
      id_name = curr_func.name + "__" + id_name;
      String lab_check = (String) argu;
      if(lab_check == null) return (R) id_name;
      if(lab_check.equals("label") && label_check){
         // function block
         curr_func.label_map.put(id_name, line_count); // put this above where label declared
         label_lineMap.put(id_name, line_count); // storing the label - line map
         if(label_debug) System.out.println("Label line: " + line_count + " Name: " + id_name);
         blockAttr battr = new blockAttr();
         curr_block = battr;
         curr_block.block_line_number = line_count;
         curr_block.succ_block = line_count + 1;
         curr_block.jump_block = -1;
         curr_func.block_list.add(curr_block);
         line_count ++;
         if(line_debug) System.out.println("IN LABEL ++");
      }
      
      return (R) id_name;
   }

}
